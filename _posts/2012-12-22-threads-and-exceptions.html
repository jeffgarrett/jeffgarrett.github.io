---
layout: post
title: "Threads and Exceptions"
date: 2012-12-22
comments: false
categories:
 - Linux
 - Threads
 - C++
 - Solaris
---

<div class='post'>
I learned something recently. One should be careful with <code>catch(...)</code>. And one should be very careful with <code>pthread_cancel</code>.<br /><br />The catch-all has a limited uses of course, since you usually know the types of exception to expect. However, there is the rare occasion for its use. What I learned is that you must always re-throw the caught exception. If you don't, <code>pthread_cancel</code> and <code>pthread_exit</code> may break.<br /><br />The reason is that on Linux, those functions work by throwing a special exception. This exception is special and does not derive from <code>std::exception</code>. You must re-throw it. It is possible to catch this exception alone and re-throw. In order to do that, see&nbsp;<a href="http://udrepper.livejournal.com/21541.html">this post</a>.<br /><br /><a href="http://skaark.wordpress.com/2010/08/26/pthread_cancel-considered-harmful/">The same logic</a> also implies that when using <code>pthread_cancel</code>, you should not use functions which serve as cancellation points in destructors. In other words, it is best not to use <code>pthread_cancel</code>.<br /><br />In summary:<br /><br /><ul><li>When using <code>catch(...)</code>, always re-throw.</li><li>Do not use <code>pthread_cancel</code>.</li></ul><br />Note: the same does not appear to be true on Solaris.<br /><br />References:&nbsp;<a href="http://udrepper.livejournal.com/21541.html">Ulrich Drepper's blog</a>,&nbsp;<a href="http://skaark.wordpress.com/2010/08/26/pthread_cancel-considered-harmful/">Kenneth's blog</a>.</div>
