---
layout: post
title: "Hard links!"
date: 2006-03-15
comments: false
categories:
 - Technology
---

<div class='post'>
I found the <a href="http://research.microsoft.com/%7Edaniel/unix-haters.html">Unix Hater's Handbook</a> for the umpteenth time.  When I was in high school, I got it out from the public library.  It's a long rant, but it's cute.  It has many stories of ancient relics, such as LispM, and early Unix frustration...  (One can also peruse some <a href="http://www.mindspring.com/%7Eblackhart/">archives</a> of the Unix Haters' mailing list.)<br /><br />In the last chapter, they bring up one of my favorite things: hard links.  Most of you probably don't care, but that hasn't stopped me yet.  Hard links are absolutely wonderful creations.  Most Unix-like filesystems behave very similarly.  Information on a file (such as its owner and permissions and where it is located on disk) are stored in a central place.  This allows for a little legerdemain.  The filename is not part of this information.  Instead, the filesystem views directories as lists of names and associated files (i.e. pointers to these blocks of information).<br /><br />This means the name, and location in the directory hierarchy are not <i>inherent</i> properties of a file.  It is possible that a file on disk is "hooked into" the directory hierarchy at no places (this shouldn't happen) or at more than one place.  This latter condition is known as a hard link.  This means one has the exact same file at two (or more) different locations in the filesystem, possibly in two different directories, possibly with different names.  This is not just an exact copy--it's the exact same file, and it's only taking up space for one.<br /><br />Why is this useful you ask?  That's a very good question.  Hard links do seem arcane at first glance.  One could use them to get a certain amount of safety.  Say you have an important file.  Hard link it to a safe place.  It can still get screwed by malicious actors--it's the same file--but if your usual editor <i>breaks</i> hard links (i.e. when it edits a file, it takes a hard linked file, and replaces it with a <i>copy</i>) you will be safe from accidentally messing it up.  You have a known good copy in the "safe place."<br /><br />An even better use is to create branches cheaply.  When I program something (I've been known to do this ;)), and I want to work on some feature or another, I can hardlink the entire directory structure over.  This is quicker than copying, and it uses much less disk space.  Then my editor can break the links for any files I edit.  And I now have two directory structures:  one with the unmodified source and one with the modified source.  And they get to share the disk space for all the unedited files!  Yes, disk is cheap, but my laptop hard disk isn't that big.  (There are even certain revision control systems that can work within this setting.  Even cooler!)<br /><br />To create a hard link, just run <code>ln filename linkname</code>.  They must be on the same filesystem.  After this you'll now have a file called <code>linkname</code> which is identical in every respect to <code>filename</code>.  If you want to do this on a whole directory structure, you can run <code>cp -al directory/ newdirectory/</code>.  Now you'll have a new directory structure <code>newdirectory/</code> with exactly the same files as <code>directory/</code>.<br /><br />Then, you may want to teach your editor to break hard links.  For vim you can do this by putting <code>set backupcopy=auto,breakhardlink</code> in your .vimrc file.<br /><script>var latexify = (function latexify() {      function create_img(eq) {         var img = document.createElement("img");         mangled_eq = eq;         mangled_eq = mangled_eq.replace(/&lt;/g, "<");         mangled_eq = mangled_eq.replace(/&gt;/g, ">");         mangled_eq = mangled_eq.replace(/&amp;/g, "&");         img.setAttribute("src", "http://latex.codecogs.com/gif.latex?" + encodeURIComponent(mangled_eq));         img.setAttribute("alt", mangled_eq);         img.setAttribute("align", "middle");         img.setAttribute("border", 0);         return img;     }      var rich_edit = document.getElementById("postingComposeBox");     if (!rich_edit) {         rich_edit = document.getElementById("richeditorframe");     }     var rich_body = rich_edit.contentDocument.getElementsByTagName("body")[0];     var contenu = rich_body.innerHTML;     while (contenu.indexOf("$$") != -1) {         var debut = contenu.indexOf("$$");         contenu = contenu.substring(0, debut) + contenu.substring(debut + 2, contenu.length);         var fin = contenu.indexOf("$$");         contenu = contenu.substring(0, fin) + contenu.substring(fin + 2, contenu.length);         var latex_eq = contenu.substring(debut, fin);         rich_body.innerHTML = contenu.substring(0, debut);         rich_body.appendChild(create_img(latex_eq));         rich_body.innerHTML += contenu.substring(fin, contenu.length);         contenu = rich_body.innerHTML;     } }); </script><script>var delatexify = (function delatexify() {     var rich_edit = document.getElementById("postingComposeBox");     if (!rich_edit) {         rich_edit = document.getElementById("richeditorframe");     }     var rich_body = rich_edit.contentDocument.getElementsByTagName("body")[0];     var imgs = rich_body.getElementsByTagName("img");     for (var i = 0; i < imgs.length; i++) {         if (imgs[i].src.indexOf("http://latex.codecogs.com/gif.latex?") == 0) {             var fragment = document.createDocumentFragment();             var txt = document.createTextNode("$$" + imgs[i].alt + "$$");             fragment.appendChild(txt);             imgs[i].parentNode.replaceChild(fragment, imgs[i]);             i--;         }     } }); </script></div>
